{"version":3,"file":"zxcvbn-ts.min.js","sources":["../src/haveIBeenPwned.ts","../src/matching.ts","../src/scoring.ts","../src/feedback.ts","../src/index.ts"],"sourcesContent":["const isNodeJs = typeof process !== 'undefined' &&\n    process.release &&\n    process.release.name === 'node';\nconst textEncode = (text) => {\n    if (isNodeJs) {\n        const utf8 = decodeURI(encodeURIComponent(text));\n        const result = new Uint8Array(utf8.length);\n        for (let i = 0; i < utf8.length; i += 1) {\n            result[i] = utf8.charCodeAt(i);\n        }\n        return result;\n    }\n    try {\n        // eslint-disable-next-line compat/compat\n        return new TextEncoder().encode(text);\n    }\n    catch (error) {\n        throw new Error(`No encoder found, ${error}`);\n    }\n};\nconst digestMessage = async (message) => {\n    const data = textEncode(message);\n    let hash = '';\n    if (isNodeJs) {\n        // eslint-disable-next-line global-require\n        const crypto = require('crypto');\n        hash = crypto.createHash('sha1').update(message).digest('hex').toUpperCase();\n    }\n    else if (crypto) {\n        const hashBuffer = await crypto.subtle.digest('SHA-1', data);\n        const hashArray = Array.from(new Uint8Array(hashBuffer));\n        hash = hashArray\n            .map((b) => b.toString(16).padStart(2, '0'))\n            .join('')\n            .toUpperCase();\n    }\n    return hash;\n};\nconst pwnedUrl = 'https://api.pwnedpasswords.com/range/';\nconst defaultNetworkErrorHandler = (_error) => {\n    return false;\n};\nexport default async (password, { universalFetch, url = pwnedUrl, networkErrorHandler = defaultNetworkErrorHandler, }) => {\n    // we don't need to check passwords with a length smaller 2 which can happen for repeat matcher or if we don't have a fetch function\n    if (!universalFetch || password.length < 2) {\n        return null;\n    }\n    const passwordHash = (await digestMessage(password)).toUpperCase();\n    const range = passwordHash.slice(0, 5);\n    const suffix = passwordHash.slice(5);\n    const response = await universalFetch(`${url}${range}`, {\n        method: 'GET',\n        headers: {\n            'Add-Padding': 'true',\n        },\n    }).catch((error) => {\n        return networkErrorHandler(error);\n    });\n    if (typeof response === 'boolean') {\n        return false;\n    }\n    if (response.status >= 400) {\n        return networkErrorHandler(response);\n    }\n    const result = await response.text();\n    const resultArray = result.split('\\r\\n');\n    return resultArray.find((entry) => {\n        const passwordHasPart = entry.split(':')[0];\n        return passwordHasPart === suffix;\n    });\n};\n//# sourceMappingURL=haveIBeenPwned.js.map","import haveIBeenPwned from './haveIBeenPwned';\n/*\n * -------------------------------------------------------------------------------\n *  Have i been pwned matching factory ---------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nexport default (universalFetch, { url, networkErrorHandler }) => {\n    return class MatchPwned {\n        async match({ password }) {\n            const matches = [];\n            const pwned = await haveIBeenPwned(password, {\n                universalFetch,\n                url,\n                networkErrorHandler,\n            });\n            if (pwned) {\n                // @ts-ignore\n                matches.push({\n                    pattern: 'pwned',\n                    pwnedAmount: parseInt(pwned.split(':')[1], 10),\n                    i: 0,\n                    j: password.length - 1,\n                    token: password,\n                });\n            }\n            return matches;\n        }\n    };\n};\n//# sourceMappingURL=matching.js.map","// TODO make some more appropriated guesses logic?\nexport default () => {\n    return 1;\n};\n//# sourceMappingURL=scoring.js.map","export default (options) => {\n    return () => {\n        return {\n            warning: options.translations.warnings.pwned,\n            suggestions: [options.translations.suggestions.pwned],\n        };\n    };\n};\n//# sourceMappingURL=feedback.js.map","import MatchPwned from './matching';\nimport scoring from './scoring';\nimport FeedbackFactory from './feedback';\nimport haveIBeenPwned from './haveIBeenPwned';\nexport const matcherPwnedFactory = (universalFetch, options, config = {}) => {\n    return {\n        Matching: MatchPwned(universalFetch, config),\n        feedback: FeedbackFactory(options),\n        scoring,\n    };\n};\nexport { haveIBeenPwned };\n//# sourceMappingURL=index.js.map"],"names":["isNodeJs","process","release","name","digestMessage","async","data","text","utf8","decodeURI","encodeURIComponent","result","Uint8Array","length","i","charCodeAt","TextEncoder","encode","error","Error","textEncode","message","hash","require","createHash","update","digest","toUpperCase","crypto","hashBuffer","subtle","Array","from","map","b","toString","padStart","join","defaultNetworkErrorHandler","_error","haveIBeenPwned","password","universalFetch","url","networkErrorHandler","passwordHash","range","slice","suffix","response","method","headers","catch","status","split","find","entry","MatchPwned","match","matches","pwned","push","pattern","pwnedAmount","parseInt","j","token","scoring","FeedbackFactory","options","warning","translations","warnings","suggestions","matcherPwnedFactory","config","Matching","feedback"],"mappings":"wFAAA,MAAMA,EAA8B,oBAAZC,SACpBA,QAAQC,SACiB,SAAzBD,QAAQC,QAAQC,KAkBdC,EAAgBC,UAClB,MAAMC,EAlBUC,KAChB,GAAIP,EAAU,CACV,MAAMQ,EAAOC,UAAUC,mBAAmBH,IACpCI,EAAS,IAAIC,WAAWJ,EAAKK,QACnC,IAAK,IAAIC,EAAI,EAAGA,EAAIN,EAAKK,OAAQC,GAAK,EAClCH,EAAOG,GAAKN,EAAKO,WAAWD,GAEhC,OAAOH,CACX,CACA,IAEI,OAAO,IAAIK,aAAcC,OAAOV,EACnC,CACD,MAAOW,GACH,MAAM,IAAIC,MAAO,qBAAoBD,IACzC,GAGaE,CAAWC,GACxB,IAAIC,EAAO,GACX,GAAItB,EAAU,CAGVsB,EADeC,QAAQ,UACTC,WAAW,QAAQC,OAAOJ,GAASK,OAAO,OAAOC,aAClE,MACI,GAAIC,OAAQ,CACb,MAAMC,QAAmBD,OAAOE,OAAOJ,OAAO,QAASpB,GAEvDgB,EADkBS,MAAMC,KAAK,IAAIpB,WAAWiB,IAEvCI,KAAKC,GAAMA,EAAEC,SAAS,IAAIC,SAAS,EAAG,OACtCC,KAAK,IACLV,aACT,CACA,OAAOL,CAAI,EAGTgB,EAA8BC,IACzB,EAEI,IAAAC,EAAA,MAAOC,GAAYC,iBAAgBC,MAJjC,wCAIiDC,sBAAsBN,MAEpF,IAAKI,GAAkBD,EAAS5B,OAAS,EACrC,OAAO,KAEX,MAAMgC,SAAsBzC,EAAcqC,IAAWd,cAC/CmB,EAAQD,EAAaE,MAAM,EAAG,GAC9BC,EAASH,EAAaE,MAAM,GAC5BE,QAAiBP,EAAgB,GAAEC,IAAMG,IAAS,CACpDI,OAAQ,MACRC,QAAS,CACL,cAAe,UAEpBC,OAAOlC,GACC0B,EAAoB1B,KAE/B,GAAwB,kBAAb+B,EACP,OAAO,EAEX,GAAIA,EAASI,QAAU,IACnB,OAAOT,EAAoBK,GAI/B,aAFqBA,EAAS1C,QACH+C,MAAM,QACdC,MAAMC,GACGA,EAAMF,MAAM,KAAK,KACdN,GAElC,EChEcS,EAAA,CAACf,GAAkBC,MAAKC,yBAC5B,MACH,WAAMc,EAAMjB,SAAEA,IACV,MAAMkB,EAAU,GACVC,QAAcpB,EAAeC,EAAU,CACzCC,iBACAC,MACAC,wBAYJ,OAVIgB,GAEAD,EAAQE,KAAK,CACTC,QAAS,QACTC,YAAaC,SAASJ,EAAMN,MAAM,KAAK,GAAI,IAC3CxC,EAAG,EACHmD,EAAGxB,EAAS5B,OAAS,EACrBqD,MAAOzB,IAGRkB,CACX,GCzBRQ,EAAA,IACW,ECFXC,EAAgBC,GACL,KACI,CACHC,QAASD,EAAQE,aAAaC,SAASZ,MACvCa,YAAa,CAACJ,EAAQE,aAAaE,YAAYb,yDCAxBc,CAAChC,EAAgB2B,EAASM,EAAS,CAAA,KAC3D,CACHC,SAAUnB,EAAWf,EAAgBiC,GACrCE,SAAUT,EAAgBC,GAC1BF"}