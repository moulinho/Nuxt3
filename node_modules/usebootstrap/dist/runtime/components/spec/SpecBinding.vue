<template>
  <b-div :class="classObject" :style="styleObject" v-bind="attrsObject" >
    <slot />
  </b-div>
</template>

<script setup lang="ts">

import { useInterval } from '@vueuse/core';
import { mergeRef , mergeFunc } from '../../../composables/utils/useAttrsMerge';
import { computed, onMounted, useAttrs , reactive, ref, toRefs, unref } from 'vue';

defineOptions({
  inheritAttrs: false
})

const attrs = useAttrs()

onMounted(() => {
  // console.log(attrs)
})
//
//
const counter = useInterval(1000, { immediate: true});

const composable = {
  class: computed(() => {
    return {
      [`composable-${counter.value}`]: counter.value % 2 == 0,
    };
  }),
  style: computed(() => {
    return {
      [`z-index`]: `${counter.value}`,
    };
  }),
  attrs: computed(() => {
    return {
      composable: counter.value,
      [`data-composable-${counter.value}`]:`${counter.value}`,
    };
  }),
  event: {
    onClick: () => {
      console.log('click1');
    }
  }
};

const current = {
  class: computed(() => {
    return {
      [`current-${counter.value}`]:`${counter.value % 2 == 0 }`,
    };
  }),
  style: computed(() => {
    return {
      [`--current-${counter.value}`]: `counter-${counter.value}`,
    };
  }),
  attrs: computed(() => {
    return {
      id: counter.value,
      [`data-current-${counter.value}`]:`${counter.value}`,
    };
  }),
  event: {
    onClick: () => {
      console.log('click2');
    }
  }
};


const classObject = mergeRef(composable.class, current.class) //OK

const styleObject = mergeRef(composable.style, current.style) //OK

const eventsObject = mergeFunc(composable.event, current.event, attrs) //OK

const attrsObject = mergeRef(composable.attrs, current.attrs,  eventsObject); // OK

// const attrsObject = mergeAttrs(composable, current); // NG

// attrsObject['onClick'] = () => {
//   console.log('click2');
// }
// const attrs = merge(composable.attrs, current.attrs);


// const mergeAttrs = (...objects) =>
//   objects.reduce(
//     (acc, cur) => {
      
//       return { ...acc, ...cur };
//     }
//   );

// const attrs =  reactive({id: 'test'}); // OK
// const attrs =  computed(() => {id: 'test'}); // NG
//const attrs =  ref({id: 'test'}); // OK
// const attrs = toRefs(current.attrs); // NG
// const attrs = current.attrs; // OK
// current.attrs.id = 'test2';
// const attrs = reactive( computed(() => { return{ id: 'test'} })); // OK

// const attrs = reactive({
//   class: mergeRef(breakpoint.class, current.class),
//   ...mergeRef(breakpoint.attrs, current.attrs)
// })  // NG

// const attrs = {
//   class: mergeRef(breakpoint.class, current.class),
//   ... reactive(mergeRef(breakpoint.attrs, current.attrs))
// } // NG





// export function hProps(...items: IHPropsModel[]) {
//  //
//  const result: IRenderPropsModel = {
//   style: {},
//  };
//  //
//  const events = new Map<string, Array<Function>>();

//  //
//  items.forEach((item) => {
//   result.style && Object.assign(result.style, unref(item.style));
//   Object.assign(result, unref(item.attr));
//   // Object.assign(result, item.event)
//   if (item.ref) {
//    set(result, 'ref', item.ref);
//   }
//   forOwn(item.event, (value, key) => {
//    if (events.has(key)) {
//     events.get(key)?.push(value);
//    }
//    else {
//     const funcs: Function[] = [value];
//     events.set(key, funcs);
//     const val = (payload: Event) => {
//      events.get(key)?.forEach(func => func(payload));
//     };
//     result[key] = val;
//    }
//   });
//  });
//  //
//  if (result.class && isEmpty(pickBy(result.class))) {
//   delete result.class;
//  }
//  //
//  if (result.style && isEmpty(pickBy(result.style))) {
//   delete result.style;
//  }
//  return result;
// }

// const mergeRef = (...objects: MaybeRef<object>[]) =>
//   objects.reduce(
//     (acc, cur) => {
//       return computed(() => { return { ...unref(acc), ...unref(cur) } });
//     }
//   );
// const mergeFunc = (...objects: MaybeRef<Record<string,Function>>[]) => {
//   //
//   const merged: Record<string,Function[]> = {};
//   objects.forEach(obj => {
//     const unrefObj = unref(obj);
//     for (const key in unrefObj) {
//       if (unrefObj.hasOwnProperty(key)) {
//         if (typeof unrefObj[key] === 'function') {
//           if (!merged[key]) {
//             merged[key] = [];
//           }
//           merged[key].push(unrefObj[key]);
//         } else {
//           merged[key] = unrefObj[key];
//         }
//       }
//     }
//   });
//   //
//   const result: Record<string,Function> = {};
//   for (const key in merged) {
//     if (merged.hasOwnProperty(key)) {
//       if (Array.isArray(merged[key])) {
//         result[key] = (...args: unknown[]) => {
//           merged[key].forEach(func => func(...args));
//         };
//       } else {
//         result[key] = merged[key];
//       }
//     }
//   }
//   return result;
// };

</script>